\section{Introduction} 
This report presents some discussions to explain how to use the period enforcer algorithm proposed by Rajkumar \cite{Raj:suspension1991} to handle self-suspending real-time tasks. The report explains briefly the underlying assumption of the period enforcer algorithm, its limitations, and how it should be correctly used to handle self-suspending sporadic real-time tasks. 

Self-suspending tasks can be classified into two models: \emph{dynamic} self-suspension and \emph{segmented} (or \emph{multi-segment}) self-suspension models. 
The dynamic self-suspension sporadic task model characterizes each
task $\tau_i$ as a $4$-tuple $(C_i,S_i,T_i,D_i)$: $T_i$ denotes the minimum inter-arrival time (or period) of $\tau_i$, $D_i$ is the relative deadline,
$C_i$ denotes the upper bound on total execution time of each job of $\tau_i$,
and $S_i$ denotes the upper bound on total suspension time of each job of $\tau_i$.  In addition to the above $4$-tuple, the segmented sporadic task model further 
characterizes the computation segments and suspension intervals as an array
$(C_{i}^1,S_{i}^1,C_{i}^2,S_{i}^2,...,S_{i}^{m_i-1},C_{i}^{m_i})$, composed of $m_i$ computation segments separated by $m_i-1$ suspension intervals. 

The basic notation in the report in \cite{Raj:suspension1991} is a \emph{deferrable task}. In Section 3 in the report in \cite{Raj:suspension1991}, it is assumed that "\emph{With deferred execution, a task $\tau_i$ can execute its $C_i$ units of execution in discrete amounts $C_i^1, C_i^2$, $\cdots$ with suspension inbetween $C_i^j$ and $C_i^{j+1}$.\footnote{The notations are alerted here to be consistent.} Without any loss of generality, we shall assume that a task $\tau_i$ can defer its entire execution time but not parts of it. That is, a task $\tau_i$ executes for $C_i$ units with no suspensions once it begins execution. Any task that does suspend after it executes for a while can be considered to be two or more tasks each with its own worst- case execution time. The only difference is that if a task $\tau_i$ is split into two tasks $\tau_i'$ followed by $\tau_i''$, then $\tau_i''$ has the same deadlines as $\tau_iâ€²$. }". 

The deferrable execution of a deferrable task imposes a scheduling penalty because one instance of a deferrable task can first defer defer its execution by some amount of time and for the next instance without any deferrable execution. The purpose of the period enforcer algorithm is to reduce such penalty. One of the main contributions in the report in \cite{Raj:suspension1991} is its Theorem 5, as follows:
\begin{quote}
{\bf Theorem 5} \cite{Raj:suspension1991}: A deferrable task that is schedulable under its worst-case conditions is also schedulable under the period enforcer algorithm.
\end{quote}

Theorem 5 in \cite{Raj:suspension1991} provides a very positive result to handle deferrable task systems. That is, if a deferrable task system can be schedulable by using a fixed-priority scheduling policy, the sporadic enforcer algorithm also provides a feasible schedule. However, recall that the deferrable task systems are based on the assumption that a deferrable task $\tau_i$ can defer its entire execution time but not parts of it. If we would like to use this result to handle segmented self-suspending task systems, the first question we have to answer is \emph{"What is the corresponding deferrable task system of a sporadic segmented self-suspending task system?"}. Unfortunately, the report in \cite{Raj:suspension1991} did not provide any explanation about the above question. In this report, we will explain three concepts:
\begin{itemize}
\item First, there exists (at least) a sporadic segmented self-suspending task system that is schedulable under fixed-priority scheduling without any enforcement, but the corresponding schedule by using period enforcer algorithm is not feasible. This shows that the result in Theorem 5 in \cite{Raj:suspension1991} has to be carefully used only based on the schedulability of \emph{deferrable task systems} instead of \emph{self-suspending task systems}.
\item Second, deriving the corresponding deferrable task system of a sporadic segmented self-suspending task system is an open problem to be done in polynomial time. The recent findings by Netlissen et al. \cite{ecrts15nelissen} can be applied, but it takes exponential time.
\item Third, the result in Theorem 5 in \cite{Raj:suspension1991} can be very useful for handling self-suspending task systems if there exist \emph{efficient} schedulability tests of the corresponding deferrable task systems or the period enforcer algorithm. However, there is no such schedulability test up to now.
\end{itemize}

\section{Schedulable Self-Suspending Tasks but Unschedulable Period Enforcer}

Let's consider a task system with $2$ tasks. Let $C_1 = 2$ and $T_1=D_1=10$ (without self-suspension). Let $C_{2,1} = 1, S_{2,1} = 6, C_{2,2}=1, T_2=D_2=11$. Suppose that we use the rate-monotonic priority assignment, i.e., $\tau_1$ has higher priority than $\tau_2$. This task system is feasible without any enforcement since at most one computation segment of a job of $\tau_2$ can be affected by $\tau_1$. The worst-case response time of task $\tau_2$ is hence $10$. 

Figure \ref{fig:example} is the resulting schedule by using the period enforcer algorithm. The first job of task $\tau_2$ (that arrives at time $0$) is executed as if there is no period enforcer. The second job (that releases at time $11$) of task $\tau_2$ requires some attention to understand how the period enforcer algorithm works. Note that the first computation segment of task $\tau_2$ does not suffer from any deferrable execution (it is postponed due to higher-priority block). Therefore, it is always placed to the ready queue and scheduled as early as possible.

Let's now look at the computation segment $C_2^2$ of the second job of task $\tau_2$. This segment is placed back to the ready queue at time $19$ after its self-suspension. Without period enforcer, this computation segment should be executed from $19$ to $20$. However, the period enforcer algorithm intentionally defers this computation segment to ensure \emph{the periodic demand} of the computation segment $C_2^2$. Therefore, this computation segment is \emph{activated} to the ready queue at time $9+T_2=9+11=20$. This results in a deadline miss.\footnote{By using the notations of \cite{Raj:suspension1991}, $ET_{2,1}^2=9, ET_{2,2}^2 = \max\{9+11, 19\}=20$.}




