
\section{Introduction} 
This report revists the \emph{period enforcer} algorithm proposed by Rajkumar \cite{Raj:suspension1991} to handle self-suspending real-time tasks. The report briefly reviews the period enforcer algorithm, explains its underlying assumptions and limitations, and discusses how it may be analyzed to correctly determine the schedulability of self-suspending sporadic real-time tasks subject to period enforcement. 

The main contributions of this report are two observations that have not been previously reported in the real-time literature:

\begin{enumerate}
	\item period enforcement can render self-suspending tasks sets unschedulable that are schedulable otherwise (i.e., period enforcement can induce deadline misses); and
	\item with current techniques, schedulability analysis of the period enforcer algorithm requires a task set transformation that is subject to exponential time complexity.
\end{enumerate}

\subsection{Preliminaries}

To date, the real-time literature on self-suspending tasks has focused on two task models: the \emph{dynamic} and the \emph{segmented} (or \emph{multi-segment}) self-suspension model. 
The dynamic self-suspension sporadic task model characterizes each
task $\tau_i$ as a $4$-tuple $(C_i,S_i,T_i,D_i)$: 
$C_i$ denotes the upper bound on the total execution time of any job of $\tau_i$,
$S_i$ denotes the upper bound on the total self-suspension time of any job of $\tau_i$,
$T_i$ denotes the minimum inter-arrival time (or period) of $\tau_i$, and $D_i$ is the relative deadline. The dynamic self-suspension model does not impose a bound on the maximum number of self-suspensions, nor does it make any assumptions as to where during a job's execution self-suspensions occur.

In contrast, the segmented sporadic task model extends the above $4$-tuple by characterizing each self-suspending task as a (fixed) finite linear sequence of computation and suspension intervals. These intervals are represented as a tuple
$(C_{i}^1,S_{i}^1,C_{i}^2,S_{i}^2,...,S_{i}^{m_i-1},C_{i}^{m_i})$, which is composed of $m_i$ computation segments separated by $m_i-1$ suspension intervals. For the simplicity of presentation, we assume that a task $\tau_i$ always starts with a computation segment. The arguments can be easily extended to handle tasks that start with self-suspensions.

The advantage of the dynamic model is that it is more flexible since it does not impose any assumptions on control flow. The advantage of the segmented model is that is allows for more accurate analysis. The period enforcer algorithm and its analysis fundamentally applies (only) to the segmented model.

The central notation in Rajkumar's analysis~\cite{Raj:suspension1991} is a \emph{deferrable task}, which matches our notion of multi-segment tasks.  Specifically, Rajkumar states that:
\begin{quote}
With deferred execution, a task $\tau_i$ can execute its $C_i$ units of execution in discrete amounts $C_i^1, C_i^2$, $\ldots$ with suspension in between $C_i^j$ and $C_i^{j+1}$. \cite[Section 3]{Raj:suspension1991}\footnote{The notation has been altered here for the sake of consistency.} 
\end{quote}
%
Central to Rajkumar's analysis~\cite{Raj:suspension1991} is a \emph{task set transformation} that splits each deferrable task with multiple segments into a corresponding number of single-segment deferrable tasks.  In the words of Rajkumar~\cite[Section 3]{Raj:suspension1991}:

\begin{quote}
	 Without any loss of generality, we shall assume that a task $\tau_i$ can defer its entire execution time but not parts of it. That is, a task $\tau_i$ executes for $C_i$ units with no suspensions once it begins execution. Any task that does suspend after it executes for a while can be considered to be two or more tasks each with its own worst-case execution time. The only difference is that if a task $\tau_i$ is split into two tasks $\tau_i'$ followed by $\tau_i''$, then $\tau_i''$ has the same deadlines as $\tau_i{{'}}$. 
\end{quote}
%
In other words, the transformation can be understood as splitting each self-suspending task into a matching number of non-self-suspending sporadic tasks subject to \emph{release jitter}, which can be easily analyzed with classic fixed-priority response-time analysis~\cite{ABRTW:93}.

It is well known that uncontrolled deferred execution (i.e, release jitter) can impose a scheduling penalty because of the potential for ``back-to-back'' execution~\cite{ABRTW:93}. That is, if a job of a deferrable task that maximally defers its execution is directly followed by a job that executes immediately without deferring its execution, then lower-priority tasks may suffer increased interference. 

The purpose of the period enforcer algorithm is to reduce such penalties for lower-priority tasks without detrimentally affecting the schedulability of self-suspending, higher-priority tasks. The latter aspect --- no detrimental effects for self-suspending tasks --- is captured concisely by Theorem 5 in the original analysis of the period enforcer algorithm \cite{Raj:suspension1991}.
\begin{quote}
{\bf Theorem 5}: A deferrable task that is schedulable under its worst-case conditions is also schedulable under the period enforcer algorithm.  \cite{Raj:suspension1991}
\end{quote}

\subsection{Questions answered in this report}

Theorem 5 in \cite{Raj:suspension1991} provides a very positive result for the analysis of deferrable task sets subject to period enforcement. That is, if the corresponding transformed task set can be shown to be schedulable under fixed-priority scheduling using \emph{any} applicable analysis, then the period enforcer algorithm also provides a feasible schedule. 

However, note that Theorem 5 in \cite{Raj:suspension1991} applies only to the \emph{transformed} task set: recall that, in the original analysis~\cite{Raj:suspension1991}, deferrable tasks are assumed to defer their entire execution time either completely or not at all (but not parts of it).  Therefore, if we would like to use the period enforcer algorithm to handle segmented self-suspending task sets, we first have to answer the following question: ``\emph{Given a set of sporadic segmented self-suspending tasks, what is the corresponding set of (single-segment) deferrable tasks?}'' That is, how do we convert given self-suspension segments into equivalent bounds on release jitter such that we may apply Theorem 5 to conclude that the system remains schedulable despite period enforcement? Unfortunately, the original proposal \cite{Raj:suspension1991} does not provide an answer to this central question. 


In this report, we make two observations pertaining to this question:
\begin{enumerate}
	\item There exist sporadic segmented self-suspending task sets that are schedulable under fixed-priority scheduling without any enforcement, but the corresponding schedule by using the period enforcer algorithm is not feasible. This shows that Theorem 5 in \cite{Raj:suspension1991} has to be  used with care --- it may be applied only in the context of the transformed single-segment deferrable task set, and not in the context of the original segmented self-suspending task set.

	\item Deriving a single-segment deferrable task set corresponding to a given set of sporadic segmented self-suspending tasks in polynomial time is an open problem. Recent findings by Nelissen et al. \cite{ecrts15nelissen} can be applied, but their method takes exponential time.
\end{enumerate}

\section{Schedulable Self-Suspending Tasks but Unschedulable Period Enforcer}
\label{sec:unschedulable}

Let's consider a task system with $2$ tasks. Let $C_1 = 2$ and $T_1=D_1=10$ (without self-suspension). Let $C_{2,1} = 1, S_{2,1} = 6, C_{2,2}=1, T_2=D_2=11$. Suppose that we use the rate-monotonic priority assignment, i.e., $\tau_1$ has higher priority than $\tau_2$. This task system is feasible without any enforcement since at most one computation segment of a job of $\tau_2$ can be affected by $\tau_1$. The worst-case response time of task $\tau_2$ is hence $10$. 

Figure \ref{fig:example} is the resulting schedule by using the period enforcer algorithm. The first job of task $\tau_2$ (that arrives at time $0$) is executed as if there is no period enforcement. The second job (that releases at time $11$) of task $\tau_2$ requires some attention to understand how the period enforcer algorithm works. Note that the first computation segment of task $\tau_2$ does not suffer from any deferrable execution (it is postponed due to higher-priority block). Therefore, it is always placed to the ready queue immediately when it arrives and scheduled as early as possible.

Let's now look at the computation segment $C_2^2$ of the second job of task $\tau_2$. This segment is placed back to the ready queue at time $19$ after its self-suspension. Without period enforcement, this computation segment should be executed from $19$ to $20$. However, the period enforcer algorithm intentionally defers this computation segment to ensure \emph{the periodic demand} of the computation segment $C_2^2$. Therefore, this computation segment is \emph{activated} to the ready queue at time $9+T_2=9+11=20$. This results in a deadline miss.\footnote{By using the notations in \cite{Raj:suspension1991}, we have $ET_{2,1}^2=9, ET_{2,2}^2 = \max\{9+11, 19\}=20$. The superscript $^2$ is for denoting the second computation segment of task $\tau_2$.}

Therefore, the above example shows that there exists (at least) a sporadic segmented self-suspending task system that is schedulable under fixed-priority scheduling without any enforcement, but the corresponding schedule by using the period enforcer algorithm is not feasible. In this example, it is also clear that we can pessimistically convert the two computation segments of task $\tau_2$ into two deferrable tasks $\tau_2^1$ and $\tau_2^2$. The deferrable time of task $\tau_2^1$ is $0$, whereas the deferrable time of task $\tau_2^2$ is at most \emph{$9$}. With the above conversion, we can clearly see that the deferrable task set $\{\tau_1, \tau_2^1, \tau_2^2\}$ is in fact not schedulable by the rate-monotonic priority assignment since we can release a job of $\tau_1$ together with a job of $\tau_2^2$ (after its worst-case deferrable time).

\section{How to Convert to the Corresponding Deferrable Task Set}
\label{sec:convert}

The example in Section \ref{sec:unschedulable} can be easily converted to a corresponding deferrable task set. However, it is in general not an easy problem to convert a self-suspending task system into a deferrable task set \emph{precisely}. We can demonstrate the difficulty by looking at a special case. Suppose that the system has $k-1$ ordinary sporadic tasks and only one segmented self-suspending task $\tau_k$. Converting a computation segment into a deferrable task requires to derive the \emph{worst-case resume time of a computation segment}, denoted as $R_k^j$ for the $j$-th computation segment of task $\tau_k$. Suppose that the worst-case response time of the $j$-th computation segment of task $\tau_k$ is $W_k^j$. It is not difficult to see that $R_k^1=0$ and $R_k^j = W_k^{j-1}+S_k^{j-1}$ for $j=2,3,\ldots,m_k-1$. So, we need to derive the worst-case response times of the computation segments of task $\tau_k$. 

With the above discussions, for the most simple case defined above, the problem is basically identical to the worst-case response time analysis of segmented self-suspending task systems. It has been recently shown by Nelissen et al. \cite{ecrts15nelissen}  calculating the worst-case response time in the above case is already a very challenging problem. Nelissen et al. \cite{ecrts15nelissen} identify several misconceptions used in the literature for this problem. After excluding those misconceptions, deriving the worst-case response time of a computation segment in pseudo-polynomial time seems to be a very difficult problem. Due to \cite{ecrts15nelissen}, the only existing solution to derive the exact $W_k^{j}$ (and hence $R_k^j$) requires exponential time complexity. And, also recall the example in \ref{sec:unschedulable}. Even if the conversion is done precisely, the deferrable task system can be more pessimistic than the original self-suspending task system with respect to the schedulability.

\section{Concluding Remarks}

This report explains how to use the period enforcer algorithm proposed by Rajkumar \cite{Raj:suspension1991} to handle segmented self-suspending real-time tasks. One key assumption in the report in \cite{Raj:suspension1991} is that a deferrable task $\tau_i$ can defer its entire execution time but not parts of it. This creates some mismatches between the original self-suspending task system and the corresponding deferrable task system.  The report in  \cite{Raj:suspension1991} did not explain how to convert a segmented self-suspending task system to a corresponding deferrable task system. We show in this report that this is non-trivial and the main claim of Theorem 5 in \cite{Raj:suspension1991} does not reflect the schedulability of the original self-suspending task system. 


Nevertheless, the result in Theorem 5 in \cite{Raj:suspension1991} can be very useful for handling self-suspending task systems if there exist \emph{efficient} schedulability tests of the corresponding deferrable task systems or the period enforcer algorithm. However, such tests do not exist yet and remain as open problems.


