\section{Introduction} 
This report presents some discussions to explain how to use the period enforcer algorithm proposed by Rajkumar \cite{Raj:suspension1991} to handle self-suspending real-time tasks. The report explains briefly the underlying assumption of the period enforcer algorithm, its limitations, and how it should be correctly used to handle self-suspending sporadic real-time tasks. 

Self-suspending tasks can be classified into two models: \emph{dynamic} self-suspension and \emph{segmented} (or \emph{multi-segment}) self-suspension models. 
The dynamic self-suspension sporadic task model characterizes each
task $\tau_i$ as a $4$-tuple $(C_i,S_i,T_i,D_i)$: $T_i$ denotes the minimum inter-arrival time (or period) of $\tau_i$, $D_i$ is the relative deadline,
$C_i$ denotes the upper bound on total execution time of each job of $\tau_i$,
and $S_i$ denotes the upper bound on total suspension time of each job of $\tau_i$.  In addition to the above $4$-tuple, the segmented sporadic task model further 
characterizes the computation segments and suspension intervals as an array
$(C_{i}^1,S_{i}^1,C_{i}^2,S_{i}^2,...,S_{i}^{m_i-1},C_{i}^{m_i})$, composed of $m_i$ computation segments separated by $m_i-1$ suspension intervals. For the simplicity of presentation, we will implicitly assume that a task $\tau_i$ always starts with a computation segment. The arguments can be easily extended to handle tasks that start with self-suspensions.

The basic notation in the report in \cite{Raj:suspension1991} is a \emph{deferrable task}. In Section 3 in the report in \cite{Raj:suspension1991}, it is assumed that "\emph{With deferred execution, a task $\tau_i$ can execute its $C_i$ units of execution in discrete amounts $C_i^1, C_i^2$, $\cdots$ with suspension inbetween $C_i^j$ and $C_i^{j+1}$.\footnote{The notations are alerted here to be consistent.} Without any loss of generality, we shall assume that a task $\tau_i$ can defer its entire execution time but not parts of it. That is, a task $\tau_i$ executes for $C_i$ units with no suspensions once it begins execution. Any task that does suspend after it executes for a while can be considered to be two or more tasks each with its own worst- case execution time. The only difference is that if a task $\tau_i$ is split into two tasks $\tau_i'$ followed by $\tau_i''$, then $\tau_i''$ has the same deadlines as $\tau_iâ€²$. }". 

The deferrable execution of a deferrable task imposes a scheduling penalty because one job of a deferrable task can first defer defer its execution by some amount of time and for the next job without any deferrable execution. The purpose of the period enforcer algorithm is to reduce such penalty. One of the main contributions in the report in \cite{Raj:suspension1991} is its Theorem 5, as follows:
\begin{quote}
{\bf Theorem 5} \cite{Raj:suspension1991}: A deferrable task that is schedulable under its worst-case conditions is also schedulable under the period enforcer algorithm.
\end{quote}

Theorem 5 in \cite{Raj:suspension1991} provides a very positive result to handle deferrable task systems. That is, if a deferrable task system can be schedulable by using a fixed-priority scheduling policy, the perioc enforcer algorithm also provides a feasible schedule. However, recall that the deferrable task systems are based on the assumption that a deferrable task $\tau_i$ can defer its entire execution time but not parts of it. If we would like to use this result to handle segmented self-suspending task systems, the first question we have to answer is \emph{"What is the corresponding deferrable task system of a sporadic segmented self-suspending task system?"}. Unfortunately, the report in \cite{Raj:suspension1991} did not provide any explanation about the above question. In this report, we will explain two concepts:
\begin{itemize}
\item First, there exists (at least) a sporadic segmented self-suspending task system that is schedulable under fixed-priority scheduling without any enforcement, but the corresponding schedule by using the period enforcer algorithm is not feasible. This shows that the result in Theorem 5 in \cite{Raj:suspension1991} has to be carefully used only based on the schedulability of \emph{deferrable task systems} instead of \emph{self-suspending task systems}.
\item Second, deriving the corresponding deferrable task system of a sporadic segmented self-suspending task system in polynomial time is an open problem. The recent findings by Netlissen et al. \cite{ecrts15nelissen} can be applied, but it takes exponential time.
\end{itemize}

\section{Schedulable Self-Suspending Tasks but Unschedulable Period Enforcer}
\label{sec:unschedulable}

Let's consider a task system with $2$ tasks. Let $C_1 = 2$ and $T_1=D_1=10$ (without self-suspension). Let $C_{2,1} = 1, S_{2,1} = 6, C_{2,2}=1, T_2=D_2=11$. Suppose that we use the rate-monotonic priority assignment, i.e., $\tau_1$ has higher priority than $\tau_2$. This task system is feasible without any enforcement since at most one computation segment of a job of $\tau_2$ can be affected by $\tau_1$. The worst-case response time of task $\tau_2$ is hence $10$. 

Figure \ref{fig:example} is the resulting schedule by using the period enforcer algorithm. The first job of task $\tau_2$ (that arrives at time $0$) is executed as if there is no period enforcement. The second job (that releases at time $11$) of task $\tau_2$ requires some attention to understand how the period enforcer algorithm works. Note that the first computation segment of task $\tau_2$ does not suffer from any deferrable execution (it is postponed due to higher-priority block). Therefore, it is always placed to the ready queue and scheduled as early as possible.

Let's now look at the computation segment $C_2^2$ of the second job of task $\tau_2$. This segment is placed back to the ready queue at time $19$ after its self-suspension. Without period enforcer, this computation segment should be executed from $19$ to $20$. However, the period enforcer algorithm intentionally defers this computation segment to ensure \emph{the periodic demand} of the computation segment $C_2^2$. Therefore, this computation segment is \emph{activated} to the ready queue at time $9+T_2=9+11=20$. This results in a deadline miss.\footnote{By using the notations in \cite{Raj:suspension1991}, we have $ET_{2,1}^2=9, ET_{2,2}^2 = \max\{9+11, 19\}=20$. The superscript $^2$ is for denoting the second computation segment of task $\tau_2$.}

Therefore, the above example shows that there exists (at least) a sporadic segmented self-suspending task system that is schedulable under fixed-priority scheduling without any enforcement, but the corresponding schedule by using period enforcer algorithm is not feasible. In this example, it is also clear that we can pessimistically convert the two computation segments of task $\tau_2$ into two deferrable tasks $\tau_2^1$ and $\tau_2^2$. The deferrable time of task $\tau_2^1$ is $0$, whereas the deferrable time of task $\tau_2^2$ is at most \emph{$9$}. With the above conversion, we can clearly see that the deferrable task set $\{\tau_1, \tau_2^1, \tau_2^2\}$ is in fact not schedulable by the rate-monotonic priority assignment since we can release a job of $\tau_1$ together with a job of $\tau_2^2$ (after its worst-case deferrable time).

\section{How to Convert to the Corresponding Deferrable Task Set}
\label{sec:convert}

The example in Section \ref{sec:unschedulable} can be easily converted to a corresponding deferrable task set. However, it is in general not an easy problem to convert a self-suspending task system into a deferrable task set. Suppose that the system has $k-1$ ordinary sporadic tasks and only one segmented self-suspending task $\tau_k$. Converting a computation segment into a deferrable task requires to derive the \emph{worst-case resume time of a computation segment}, denoted as $R_k^j$ for the $j$-th computation segment of task $\tau_k$. Suppose that the worst-case response time of the $j$-th computation segment of task $\tau_k$ is $W_k^j$. It is not difficult to see that $R_k^1=0$ and $R_k^j = W_k^{j-1}+S_k^{j-1}$ for $j=2,3,\ldots,m_k-1$. So, we need to derive the worst-case response times of the computation segments of task $\tau_k$. 

With the above discussions, for the most simple case defined above, the problem is basically identical to the worst-case response time analysis of segmented self-suspending task systems. It has been recently shown by Nelissen et al. \cite{ecrts15nelissen} that calculating the worst-case response time of such a problem is a challenging problem. Nelissen et al. \cite{ecrts15nelissen} explain misconceptions conducted by using wrong assumptions in the critical instant theorem. However, their approaches require exponential time complexity to derive $W_k^{j}$. 

\section{Concluding Remarks}

This report explains how to use the period enforcer algorithm proposed by Rajkumar \cite{Raj:suspension1991} to handle segmented self-suspending real-time tasks. One key assumption in the report in \cite{Raj:suspension1991} is that the deferrable task systems are based on the assumption that a deferrable task $\tau_i$ can defer its entire execution time but not parts of it. This creates some mismatches between the original sporadic task system and the corresponding deferrable task system.  The report in  \cite{Raj:suspension1991} did not explain how to convert a segmented self-suspending task system to a corresponding deferrable task system. We show in this report that this is non-trivial and the main claim of Theorem 5 in \cite{Raj:suspension1991} does not reflect the schedulability of the original self-suspending task system. 


Nevertheless, the result in Theorem 5 in \cite{Raj:suspension1991} can be very useful for handling self-suspending task systems if there exist \emph{efficient} schedulability tests of the corresponding deferrable task systems or the period enforcer algorithm. However, such tests do not exist yet and remain as open problems.


