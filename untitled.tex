\section{Introduction} 
This report presents some discussions to explain how to use the period enforcer algorithm proposed by Rajkumar \cite{Raj:suspension1991} to handle self-suspending real-time tasks. The report explains briefly the underlying assumption of the period enforcer algorithm, its limitations, and how it should be correctly used to handle self-suspending sporadic real-time tasks. 

Self-suspending tasks can be classified into two models: \emph{dynamic} self-suspension and \emph{segmented} (or \emph{multi-segment}) self-suspension models. 
The dynamic self-suspension sporadic task model characterizes each
task $\tau_i$ as a $4$-tuple $(C_i,S_i,T_i,D_i)$: $T_i$ denotes the minimum inter-arrival time (or period) of $\tau_i$, $D_i$ is the relative deadline,
$C_i$ denotes the upper bound on total execution time of each job of $\tau_i$,
and $S_i$ denotes the upper bound on total suspension time of each job of $\tau_i$.  In addition to the above $4$-tuple, the segmented sporadic task model further 
characterizes the computation segments and suspension intervals as an array
$(C_{i}^1,S_{i}^1,C_{i}^2,S_{i}^2,...,S_{i}^{m_i-1},C_{i}^{m_i})$, composed of $m_i$ computation segments separated by $m_i-1$ suspension intervals. 

The basic notation in the report in \cite{Raj:suspension1991} is a \emph{deferrable task}. In Section 3 in the report in \cite{Raj:suspension1991}, it is assumed that "\emph{Without any loss of generality, we shall assume that a task $\tau_i$ can defer its entire execution time but not parts of it. hat is, a task τi executes for Ci units with no suspensions once it begins execution. Any task that does suspend after it executes for a while can be considered to be two or more tasks each with its own worst- case execution time. The only difference is that if a task $\tau_i$ is split into two tasks $\tau_i'$ followed by $\tau_i''$, then $\tau_i''$ has the same deadlines as $\tau_i′$. }". 

The period enforcer algorithm can only be applied for the segmented case. 